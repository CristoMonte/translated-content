---
title: var
slug: Web/JavaScript/Reference/Statements/var
tags:
  - JavaScript
  - Statement
  - 声明
translation_of: Web/JavaScript/Reference/Statements/var
---
<div>{{jsSidebar("Statements")}}</div>

<p><strong><code>var</code> 语句</strong>声明一个函数作用域或全局作用域的变量，并且可以选择是否为其初始化一个值。</p>

<p>{{EmbedInteractiveExample("pages/js/statement-var.html")}}</p>



<h2 id="语法">语法</h2>

<pre class="brush: js notranslate"><code> <span class="token keyword">var</span> varname1 [= value1] [, varname2 [= value2] ... [, varnameN [= valueN]]];</code></pre>

<dl>
 <dt><code>varnameN</code></dt>
 <dd>变量名。变量名可以定义为任何合法标识符。</dd>
</dl>

<dl>
 <dt><code>valueN</code> <span class="badge inline optional">可选</span></dt>
 <dd>变量的初始化值。该值可以是任何合法的表达式。默认值为 <code>undefined</code>。</dd>
</dl>

<p>另外，<a href="/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值</a> 语法也可以用来声明变量。</p>
<pre class="brush:js">
var { bar } = foo; // where foo = { bar:10, baz:12 };
/* 创建了一个名为bar，值为10的变量 */
</pre>


<h2 id="Description" name="Description">描述</h2>

<p>变量声明，无论发生在何处，都在执行任何代码之前进行处理。这被称之为 <em>变量提升（hoisting）</em>， 会在接下来的内容中讨论。</p>

<p>用 <code>var</code> 声明的变量的作用域是它当前的执行上下文及其闭包，它可以是嵌套函数，而对于声明在任何函数外的变量来说则是全局。你可以使用<code>var</code>重复声明同一个变量，这是允许的，即使在严格模式下也不会报错。并且重复声明也不会改变变量的值，除非重新进行赋值操作。</p>
<pre class="brush: js">
'use strict';
function foo() {
  var x = 1;
  function bar() {
    var y = 2;
    console.log(x); // 1 (function `bar` closes over `x`)
    console.log(y); // 2 (`y` is in scope)
  }
  bar();
  console.log(x); // 1 (`x` is in scope)
  console.log(y); // ReferenceError in strict mode, `y` is scoped to `bar`
}

foo();
</pre>

<p>用<code>var</code>声明的变量的创建在执行过程过优先于任何代码，这就是我们常说的变量提升，提升后变量的初始值是<code>undefined</code>。</p>
<pre class="brush: js">
'use strict';
console.log(x);                // undefined (note: not ReferenceError)
console.log('still going...'); // still going...
var x = 1;
console.log(x);                // 1
console.log('still going...'); // still going...
</pre>

<p>
  在全局上下文中，用<code>var</code>声明的变量会被添加为全局对象的不可配置属性。这意味着这个变量的属性描述符不能更改，并且不能用{{JSxRef("Operators/delete", "delete")}}删除。对应的属性名也会添加到
  <a href="https://www.ecma-international.org/ecma-262/10.0/index.html#sec-global-environment-records">全局环境记录</a>
  （全局词法环境的组成部分）的内部<code>[[VarNames]]</code>插槽列表中。<code>[[VarNames]]</code>中的名称列表使得运行时能区分全局变量和声明在全局对象上的简单属性。
</p>
<pre class="brush: js">
'use strict';
var x = 1;
globalThis.hasOwnProperty('x'); // true
delete globalThis.x; // 严格模式下报TypeError错误，非严格环境下静默失败
delete x;  // 严格模式下报SyntaxError错误，非严格环境下静默失败
</pre>

<p>请注意，在NodeJS<a href="http://www.commonjs.org/">CommonJS</a>模块和原生<a href="/zh-CN/docs/Web/JavaScript/Guide/Modules">ECMAScript modules</a>中，顶级变量声明的范围仅限于模块中，因此不会作为属性添加到全局对象上。</p>

<h3 id="无限定标识符分配">无限定标识符的赋值</h3>
<p>*译者注：无限定标识符是指在标识符前没有指定作用域，与之相对的是有限定标识符</p>

<p>全局对象位于作用域链的顶部，当尝试将一个变量名解析为某个具体的值的时候，会在作用域链中搜索。这意味着全局对象上的属性在任何作用域中都可以很方便的看到，而不需要使用<code>globalThis.</code>或者<code>window.</code>或者<code>global.</code>前缀</p>

<p>所以你可以直接这样写：</p>
<pre class="brush: js">
function foo() {
  String('s') // 请注意`String`方法是隐式可见的
}
</pre>

<p>因为</p>
<pre class="brush: js">
  globalThis.hasOwnProperty('String') // true
</pre>

<p>所以最后会在全局对象上搜索无限定标识符，你可以直接写无限定名的<code>String</code>而不需要写<code>globalThis.String</code>，非严格模式下，会对于无限定标识符的赋值进行推断，如果在作用域链上没有找到同名的变量，那便会将变量声明为全局对象上的属性。</p>
<pre class="brush: js">
foo = 'f' // 非严格模式下， 推断为希望将属性`foo`声明在全局对象上
globalThis.hasOwnProperty('foo') // true
</pre>

<p>
  在ECMAScript 5中，此行为已针对
  <a href="/zh-CN/docs/Web/JavaScript/Reference/Strict_mode">严格模式</a>
  进行更改。为了避免在全局对象上意外创建属性，严格模式下对无限定标识符进行赋值会报<code>ReferenceError</code>错误。
</p>

<p>请注意，上面例子中，并不像我们认为的那样是隐式声明或者未声明的变量，只是看起来相似的语法而已。（*译者注：上面例子中String是全局对象上的内置属性，foo只是被推断为希望挂载到全局对象上的属性，所以并不是隐式声明或者未声明变量，只是最后结果的表现形式一样。）</p>

<h3 id="变量提升">变量提升</h3>
<p>由于变量声明（以及其他声明）是在任意代码执行之前处理的，所以在代码中的任意位置声明变量等同于在顶部声明。这意味着变量可以在声明之前使用，这个行为叫做<em>变量提升</em>。<em>变量提升</em>就像是把所有的变量声明移动到函数或者全局代码的顶部。</p>

<pre class="brush: js">bla = 2
var bla;
// ...

// 可以隐式地（implicitly）将以上代码理解为：

var bla;
bla = 2;
</pre>

<p>因此，建议始终在其作用域顶部（全局代码的顶部和函数代码的顶部）声明变量，以便知道哪些变量是函数作用域的（本地），而哪些变量需要在作用域链上解析。</p>

<p>重要的是，变量提升只会影响变量声明，而不会影响其值的初始化。只有到达赋值语句时，才会对变量进行赋值：</p>

<pre class="brush: js">function do_something() {
  console.log(bar); // undefined
  var bar = 111;
  console.log(bar); // 111
}

// 可以隐式地（implicitly）将以上代码理解为：
function do_something() {
  var bar;
  console.log(bar); // undefined
  bar = 111;
  console.log(bar); // 111
}</pre>

<h2 id="Examples" name="Examples">例子</h2>

<h3 id="声明并初始化两个变量：">声明并初始化两个变量：</h3>

<pre class="brush: js">var a = 0, b = 0;
</pre>

<h3 id="用单个字符串赋值两个变量：">用单个字符串赋值两个变量：</h3>

<pre class="brush: js">var a = "A";
var b = a;

// 等同于：

var a, b = a = "A";
</pre>

<p>留意其中的顺序：</p>

<pre class="brush: js">var x = y, y = 'A';
console.log(x + y); // undefinedA
</pre>

<p>在这里，<code>x</code> 和 <code>y</code> 在代码执行前就已经创建了，而赋值操作发生在创建之后。当 <code>x = y</code> 执行时，<code>y</code> 已经存在，所以不会抛出<code>ReferenceError</code>错误，它的值是<code>undefined</code>。所以 <code>x</code> 被赋值为undefined。然后，<code>y</code> 被赋值为'A'。于是，在执行完第一行代码之后<code>x === undefined &amp;&amp; y === 'A'</code>，所以最后的结果是<code>undefinedA</code>。</p>

<h3 id="多个变量的初始化">多个变量的初始化</h3>

<pre class="brush: js">var x = 0;
var x = 0;
function f(){
  var x = y = 1; // x声明在函数内部，y声明在全局
}
f();

console.log(x, y); // 0, 1

// 非严格模式：
// x 是全局变量；
// y 被意外泄漏到了全局。 </pre>

<p>相同的例子在严格模式下：</p>
<pre class="brush: js">
'use strict';

var x = 0;
function f() {
  var x = y = 1; // 在严格模式下抛出ReferenceError错误
}
f();

console.log(x, y);
</pre>

<h3 id="隐式全局变量和外部函数作用域">隐式全局变量和外部函数作用域</h3>

<p>看起来像是隐式全局变量的变量也有可能是外部函数作用域中变量的引用。</p>

<pre class="brush: js">
var x = 0;  // x是顶级作用域中的变量，并且赋值为0。

console.log(typeof z); // undefined，因为z还不存在。

function a() { // 当a被调用时，
  var y = 2;   // y被声明成函数a作用域中的变量，然后赋值成2。

  console.log(x, y);   // 0 2

  function b() {       // 当b被调用时，
    x = 3;  // 顶级作用域中的变量x被赋值为3
    y = 4;  // 函数a作用域中的y变量被赋值为4。
    z = 5;  // 创建新的顶级作用域变量z，并且给z赋值为5。
  }         // (在严格模式下（strict mode）抛出ReferenceError)

  b();      // 调用b时创建了顶级作用域变量z。
  console.log(x, y, z);  // 3 4 5
}

a();                   // 调用a时同时调用了b。
console.log(x, z);     // 3 5
console.log(typeof y); // undefined，因为y是a函数的本地（local）变量。
</pre>

<h2 id="规范">规范</h2>

<p>{{Specifications}}</p>

<h2 id="浏览器兼容性">浏览器兼容性</h2>

<p>{{Compat("javascript.statements.var")}}</p>

<h2 id="参见">参见</h2>

<ul>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/Statements/let"><code>let</code></a></li>
 <li><a href="/zh-CN/docs/Web/JavaScript/Reference/Statements/const"><code>const</code></a></li>
</ul>
